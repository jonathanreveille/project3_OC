

# si la lettre est égale à 0, 
        #on ajoute à self.passage la Position()

        # convenir le caractère. Si colonne est 0 alors on fera un append Position (colonne, ligne) dans self.passage
        # Si W, position(colonne,ligne) dans self.walls
        # Si S, self.start position(colonne, ligne), Ajouter 'append' dans self.passage
        # Si E, self.exit = position(colonne, ligne)

        #Position.self.passage

        # Tout ce qui n'est pas passage, est un mur
#self.widthx= n_colonne +1
#self.length = n_ligne +1



        # 1) liste vide de caractère
        # 2) 2 boucle inbriquées : for ligne in range(self.length)
                                        # colonne in range(self.8)
        
        # test si position = position du HERO --> afficher avec "H"
        # si position passage : if position in self.passage:
        # si position mur  : if position in self.walls:
        # 
        # "\n"
            #"".join()
            #return above


        #list = characters 
        #for i in characters:
        #   for colonne et ligne 0 a 14

        #créer position ()
        #   ajoute 0 à ma liste
        #    Si position, fin de ligne, ajoute "\n"
        #"".join(liste de caractere)




   # def __contains__(self, position):

        #""" This methods keeps the HERO on the MAP horizontally, he can't go outside the map's length (x) and width (y) """

       # if position.x >= 0 and position.x < self.length and position.y >= 0 and position.y < self.width:
       #     return True
       # return False






#def main():
  #  gameboard = GameBoard()
  #  gameboard.load_map()
 #   print(gameboard)


#if __name__ == "__main__":
  # main()


#GameBoard créer un attribut qui est une liste de passage

#Dés qu'on rencontre un point, on rajoute les coordonnées de ce point dans la liste

#ce qui est # on ne l'ajoute pas 
#ce qui est . on l'ajoute 

#car . est un passage autorisé 

#tout ca dans GameBoard

#Adapter la méthode str pour afficher le labyrinthe

#Approprié de __contains__

#position est dans la liste des passages

#Adapter classe mouvement (x et y)


#Parcourir les lignes. Et colonnes d’un fichier 

# With open (map1.txt, « r ») as fichier:
# for n_ligne, ligne in enumerate(fichier): 
    #for n_colonne, colonne in enumerate(ligne): 
   # faire quelque chose avec les Position(n_colonne, n_ligne)
# fichier <- ouvrir le fichier


#with open(map1.txt, "r") as fichier:
 #   for n_ligne, ligne in enumerate(fichier):
 #      for n_colonne, colonne in enumerate(ligne):


# . = passage
# = mur 
#s = start
#e = end

#15 lignes de 15 caractères
#GameBoard créer un attribut qui est une liste de passage
#Dés qu'on rencontre un point, on rajoute les coordonnées de ce point dans la liste
#ce qui est # on ne l'ajoute pas 
#ce qui est . on l'ajoute 
#car . est un passage autorisé 
#tout ca dans GameBoard

#Adapter la méthode str pour afficher le labyrinthe

#Approprié de __contains__
#position est dans la liste des passages
#Adapter classe mouvement (x et y)